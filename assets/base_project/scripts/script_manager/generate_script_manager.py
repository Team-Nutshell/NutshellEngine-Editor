# Python script used to auto-generate the script manager
# Called from CMake

import sys
import os
import re

def parseVariableLineTokens(tokens, usingNamespaceStd, usingNamespaceNtshEngnMath):
	type = tokens[0]
	name = tokens[1]
	if type == "bool":
		return (name, "Boolean")
	elif type == "int8_t":
		return (name, "Int8")
	elif type == "int16_t":
		return (name, "Int16")
	elif type == "int" or type == "int32_t":
		return (name, "Int32")
	elif type == "int64_t":
		return (name, "Int64")
	if type == "uint8_t":
		return (name, "Uint8")
	elif type == "uint16_t":
		return (name, "Uint16")
	elif type == "uint" or type == "uint32_t":
		return (name, "Uint32")
	elif type == "uint64_t" or type == "size_t":
		return (name, "Uint64")
	elif type == "float":
		return (name, "Float32")
	elif type == "double":
		return (name, "Float64")
	elif (usingNamespaceStd and type == "string") or (not usingNamespaceStd and type == "std::string"):
		return (name, "String")
	elif (usingNamespaceNtshEngnMath and type == "vec2") or (not usingNamespaceNtshEngnMath and type == "Math::vec2"):
		return (name, "Vector2")
	elif (usingNamespaceNtshEngnMath and type == "vec3") or (not usingNamespaceNtshEngnMath and type == "Math::vec3"):
		return (name, "Vector3")
	elif (usingNamespaceNtshEngnMath and type == "vec4") or (not usingNamespaceNtshEngnMath and type == "Math::vec4"):
		return (name, "Vector4")
	elif (usingNamespaceNtshEngnMath and type == "quat") or (not usingNamespaceNtshEngnMath and type == "Math::quat"):
		return (name, "Quaternion")
	
	return ("", "Unknown")

scriptNames = []
scriptPaths = []
scriptEditableVariables = []

scriptDefine = "NTSHENGN_SCRIPT"
editableVariableDefine = "NTSHENGN_EDITABLE_VARIABLE"

outputFile = open(sys.argv[1] + "/scripts/script_manager/ntshengn_script_manager.cpp", "w")
output = "// This file is automatically generated by generate_script_manager.py from CMake\n\n"
output += "#include \"ntshengn_script_manager.h\"\n\n"
for filePath in os.listdir(sys.argv[1] + "/scripts/"):
	if os.path.isfile(sys.argv[1] + "/scripts/" + filePath):
		with open(sys.argv[1] + "/scripts/" + filePath, 'r') as file:
			fileContent = file.read()
			scriptName = re.search(scriptDefine + "(.*)", fileContent)
			if scriptName != None:
				output += "#include \"../" + filePath + "\"\n"
				scriptNames.append(scriptName.group()[16:len(scriptName.group()) - 2].strip())
				scriptPaths.append(sys.argv[1] + "/scripts/" + filePath)

				scriptEditableVariables.append([])
				usingNamespaceStd = fileContent.find("using namespace std;") != -1
				usingNamespaceNtshEngnMath = fileContent.find("using namespace NtshEngn::Math;") != -1
				currentParsing = fileContent
				editableScriptVariableIndex = currentParsing.find(editableVariableDefine)
				while editableScriptVariableIndex != -1:
					currentParsing = currentParsing[editableScriptVariableIndex + len(editableVariableDefine):]
					variableLine = currentParsing[:currentParsing.find(';')]
					variableLineTokens = variableLine.split()
					scriptEditableVariables[-1].append(parseVariableLineTokens(variableLineTokens, usingNamespaceStd, usingNamespaceNtshEngnMath))
					editableScriptVariableIndex = currentParsing.find(editableVariableDefine)

if len(scriptNames) != 0:
	output += "\n"

output += "NtshEngn::Scriptable NtshEngn::ScriptManager::createScriptable(const std::string& scriptName) {\n"
if len(scriptNames) == 0:
	output += "\tNTSHENGN_UNUSED(scriptName);\n\n"
output += "\tScriptable scriptable;\n\n"
for i, scriptName in enumerate(scriptNames):
	output += "\t"
	if i != 0:
		output += "else "
	output += "if (scriptName == \"" + scriptName + "\") {\n"
	output += "\t\t" + scriptName + "* script = createScript<" + scriptName + ">();\n"
	output += "\t\tscript->createEditableScriptVariableMap();\n"
	output += "\t\tscriptable.script = script;\n"
	output += "\t}\n"
if len(scriptNames) != 0:
	output += "\n"
output += "\treturn scriptable;\n"
output += "}\n\n"

for i, scriptName in enumerate(scriptNames):
	output += "void " + scriptName + "::createEditableScriptVariableMap() {\n"
	for scriptEditableVariable in scriptEditableVariables[i]:
		if scriptEditableVariable[1] != "Unknown":
			output += "\teditableScriptVariables[\"" + scriptEditableVariable[0] + "\"] = { NtshEngn::EditableScriptVariableType::" + scriptEditableVariable[1] + ", &" + scriptEditableVariable[0] + " };\n"
	output += "}\n\n"

output += "extern \"C\" NTSHENGN_SCRIPT_MANAGER_API NtshEngn::ScriptManagerInterface* createScriptManager() {\n"
output += "\treturn new NtshEngn::ScriptManager;\n"
output += "}\n\n"

output += "extern \"C\" NTSHENGN_SCRIPT_MANAGER_API void destroyScriptManager(NtshEngn::ScriptManagerInterface* sm) {\n"
output += "\tdelete sm;\n"
output += "}"

outputFile.write(output)